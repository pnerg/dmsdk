package org.dmonix.xml;

import java.io.*;
import java.net.URL;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;
import javax.xml.transform.*;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;

import org.w3c.dom.*;
import org.xml.sax.InputSource;
import org.xml.sax.SAXException;

import org.dmonix.io.IOUtil;

/**
 * XML utility class. The class provides functionality for easy management of XML data
 * <p>
 * Copyright: Copyright (c) 2003
 * </p>
 * <p>
 * Company: dmonix.org
 * </p>
 * 
 * @author Peter Nerg
 * @since 1.0
 */
public abstract class XMLUtil {

    /** The XML transformer. */
    private static Transformer transformer = null;

    /** The XML document builder. */
    private static DocumentBuilder docBuilder;

    private static final String COMMENT_DONT_ALTER = "\nDo not edit this file manually it could cause the program to misbehave\n";

    /** The logger instance for this class */
    private static final Logger log = Logger.getLogger(XMLUtil.class.getName());

    static {
        try {
            transformer = TransformerFactory.newInstance().newTransformer();
            transformer.setOutputProperty(OutputKeys.ENCODING, "ISO-8859-1");
            transformer.setOutputProperty(OutputKeys.STANDALONE, "yes");
            transformer.setOutputProperty(OutputKeys.INDENT, "yes");
        } catch (Exception ex) {
            log.log(Level.SEVERE, "Could not configure XML transformer", ex);
        }

        try {
            DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
            factory.setNamespaceAware(true);
            factory.setValidating(true);
            docBuilder = factory.newDocumentBuilder();
            docBuilder.setErrorHandler(new DefaultErrorHandler());
            docBuilder.setEntityResolver(new DefaultEntityResolver());
        } catch (Exception ex) {
            log.log(Level.SEVERE, "Could not configure XML document builder", ex);
        }
    }

    /**
     * Creates and appends a child element to the supplied element.
     * 
     * @param document
     *            The document containing the element to append to
     * @param element
     *            The element to append the child to
     * @param elementName
     *            The name of the element
     * @return The appended child element
     */
    public static Element appendChildElement(Document doc, Element element, String elementName) {
        Element e = doc.createElement(elementName);
        element.appendChild(e);
        return e;
    }

    /**
     * Creates and appends an element with a single text node to the supplied documents root.
     * 
     * @param document
     *            The document to append the element to
     * @param name
     *            The name of the new element
     * @param value
     *            The textual value of the element
     * @return The appended child element
     */
    public static Element appendChildElement(Document doc, String name, String value) {
        return appendChildElement(doc.getDocumentElement(), name, value);
    }

    /**
     * Creates and appends a child element with a single text node to the supplied element.
     * 
     * @param element
     *            The element to append the child to
     * @param elementName
     *            The name of the element
     * @param elementValue
     *            The value of the element
     * @return The appended child element
     * @since 1.1
     */
    public static Element appendChildElement(Element element, String elementName, String elementValue) {
        Document doc = element.getOwnerDocument();
        Element e = doc.createElement(elementName);
        e.appendChild(doc.createTextNode((elementValue == null) ? "" : elementValue));
        element.appendChild(e);
        return e;
    }

    /**
     * Creates and appends a child element to the supplied element.
     * 
     * @param element
     *            The element to append the child to
     * @param elementName
     *            The name of the element
     * @return The appended child element
     * @since 1.1
     */
    public static Element appendChildElement(Element element, String elementName) {
        Document doc = element.getOwnerDocument();
        Element e = doc.createElement(elementName);
        element.appendChild(e);
        return e;
    }

    /**
     * Compare two documents. <br>
     * Basically this method will invoke <code>compare(Element e1, Element e2)</code> using the root elements of the provided documents.
     * 
     * @param d1
     * @param d2
     * @return
     * @since 2.0
     * @see #compare(Element, Element)
     */
    public static boolean compare(Document d1, Document d2) {

        if (d1 == null || d2 == null)
            return false;

        if (d1.equals(d2))
            return true;

        return compare(d1.getDocumentElement(), d2.getDocumentElement());
    }

    /**
     * Compare two elements.
     * 
     * <pre>
     * The method will check that the provided elements have the same name and the same attributes.
     * It will the proceed to recursively compare all the child elements.
     * The child elements need not neccesarily bee in the same order as long as they are on the same level
     * E.g.
     * <code>
     *  &lt;AAA&gt;
     *    &lt;BBB/&gt;
     *    &lt;CCC/&gt;
     *  &lt;/AAA&gt;
     * </code>
     * is equal to
     * <code>
     *  &lt;AAA&gt;
     *    &lt;CCC/&gt;
     *    &lt;BBB/&gt;
     *  &lt;/AAA&gt;
     * </code>
     * </pre>
     * 
     * @param e1
     * @param e2
     * @return
     * @since 2.0
     */
    public static boolean compare(Element e1, Element e2) {

        if (e1 == null || e2 == null)
            return false;

        if (e1.equals(e2))
            return true;

        if (!e1.getTagName().equals(e2.getTagName()))
            return false;

        if (!compareAttributes(e1, e2))
            return false;

        NodeList children = e1.getChildNodes();
        Element etmp;
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() != Node.ELEMENT_NODE)
                continue;

            etmp = (Element) children.item(i);
            compare(etmp, getChildElementByTagName(e2, etmp.getTagName()));
        }

        return true;
    }

    /**
     * Compare the attributes for two elements.
     * 
     * @param e1
     * @param e2
     * @return
     */
    public static boolean compareAttributes(Element e1, Element e2) {
        NamedNodeMap attributes1 = e1.getAttributes();
        NamedNodeMap attributes2 = e2.getAttributes();

        if (attributes1.getLength() != attributes2.getLength())
            return false;

        Node node1, node2;
        for (int i = 0; i < attributes1.getLength(); i++) {
            node1 = attributes1.item(i);
            node2 = attributes2.getNamedItem(node1.getNodeName());
            if (node2 == null || !node1.getNodeValue().equals(node2.getNodeValue()))
                return false;
        }

        return true;
    }

    /**
     * Converts the input document into a Map. <br>
     * The name of each found element will be the key in the Map and the value of the element will be the value in the Map.<br>
     * I case the same element occurrs several time, the latest value will take precedence.
     * 
     * @param document
     *            The input document
     * @return The Map, empty if no elements were found
     */
    public static Map<String, String> documentToMap(Document doc) {
        Map<String, String> hashTable = new HashMap<String, String>();
        Element e = doc.getDocumentElement();
        if (e == null)
            return hashTable;

        writeChildElementsToMap(hashTable, e);

        return hashTable;
    }

    /**
     * Gets the string representation of an XML document. <br>
     * The resulting string is trimmed to remove redundant white spaces from the beginning and end of the string.
     * 
     * @param document
     *            The document
     * @return The string representation of the document, null if an error occurred
     * @see documentToWriter(Document, Writer)
     */
    public static String documentToString(Document doc) {
        StringWriter sw = new StringWriter();
        try {
            documentToWriter(doc, sw);
        } catch (Exception ex) {
            return null;
        }
        return sw.toString().trim();
    }

    /**
     * Writes the document to a file.
     * 
     * @param document
     *            The document
     * @param file
     *            The target file
     * @throws IOException
     * @throws TransformerException
     * @see documentToStream(Document, OutputStream)
     */
    public static void documentToFile(Document doc, File file) throws IOException, TransformerException {
        FileOutputStream fostream;
        try {
            fostream = new FileOutputStream(file);
        } catch (FileNotFoundException ex) {
            file.getParentFile().mkdirs();
            fostream = new FileOutputStream(file);
        }
        documentToStream(doc, fostream);
        fostream.close();
        fostream = null;
    }

    /**
     * Writes the document to a file.
     * 
     * @param document
     *            The document
     * @param file
     *            The target file name
     * @throws IOException
     * @throws TransformerException
     * @see documentToStream(Document, OutputStream)
     */
    public static void documentToFile(Document doc, String file) throws IOException, TransformerException {
        documentToFile(doc, new File(file));
    }

    /**
     * Writes the document to a supplied outputstream.
     * 
     * @param document
     *            The document
     * @param ostream
     *            The target stream
     * @throws IOException
     * @throws TransformerException
     */
    public static void documentToStream(Document doc, OutputStream ostream) throws IOException, TransformerException {
        documentToStream(doc, ostream, false);
    }

    /**
     * Writes the document to a supplied outputstream.
     * 
     * @param document
     *            The document
     * @param ostream
     *            The target stream
     * @param closeStream
     *            If the outputstream is to be closed after write
     * @throws IOException
     * @throws TransformerException
     */
    public static void documentToStream(Document doc, OutputStream ostream, boolean closeStream) throws IOException, TransformerException {
        transformer.transform(new DOMSource(doc), new StreamResult(new BufferedOutputStream(ostream)));
        ostream.flush();
        if (closeStream)
            ostream.close();
    }

    /**
     * Writes the document to a supplied writer.
     * 
     * @param document
     *            The document
     * @param writer
     *            The target writer
     * @throws IOException
     * @throws TransformerException
     */
    public static void documentToWriter(Document doc, Writer writer) throws IOException, TransformerException {
        transformer.transform(new DOMSource(doc), new StreamResult(new BufferedWriter(writer)));
        writer.flush();
    }

    /**
     * Creates a new empty XML document.
     * 
     * @return the document
     */
    public static Document newDocument() {
        return docBuilder.newDocument();
    }

    /**
     * Creates a new XML document out of the provided string.
     * 
     * @param s
     *            The string to parse
     * @return the document
     * @throws IOException
     * @throws SAXException
     */
    public static Document newDocument(String s) throws IOException, SAXException {
        return docBuilder.parse(new InputSource(new StringReader(s)));
    }

    /**
     * Writes the XML node to a supplied outputstream.
     * 
     * @param node
     *            The node
     * @param ostream
     *            The target stream
     * @throws IOException
     * @throws TransformerException
     */
    public static void nodeToStream(Node node, OutputStream ostream) throws IOException, TransformerException {
        transformer.transform(new DOMSource(node), new StreamResult(new BufferedOutputStream(ostream)));
        ostream.flush();
    }

    /**
     * Gets the string representation of an XML node. <bt>The resulting string is trimmed to remove redundant white spaces from the beginning and end of the
     * string.
     * 
     * @param node
     *            The node
     * @return The string representation of the node, null if an error occurred
     * @see documentToWriter(Document, Writer)
     */
    public static String nodeToString(Node node) {
        StringWriter sw = new StringWriter();
        String result = null;
        try {
            nodeToWriter(node, sw);
            result = sw.toString().trim();
            sw.close();
        } catch (Exception ex) {
            return null;
        }
        return result;
    }

    /**
     * Writes the XML node to a supplied writer.
     * 
     * @param node
     *            The node
     * @param writer
     *            The target writer
     * @throws IOException
     * @throws TransformerException
     */
    public static void nodeToWriter(Node node, Writer writer) throws IOException, TransformerException {
        transformer.transform(new DOMSource(node), new StreamResult(new BufferedWriter(writer)));
        writer.flush();
    }

    /**
     * Recursively removes all empty child text nodes starting from the provided node. <br>
     * The method will also trim the non empty text nodes, i.e. any white spaces in the beginning and the end of the text node will be removed.
     * 
     * @param node
     *            The node to normalize
     */
    public static void normalizeDocument(Node node) {
        if (!node.hasChildNodes())
            return;

        NodeList nodeList = node.getChildNodes();
        String nodeValue;
        for (int i = 0; i < nodeList.getLength(); i++) {
            Node n = nodeList.item(i);

            if (n.getNodeType() == Node.TEXT_NODE) {
                nodeValue = n.getNodeValue().trim();

                // It the node is empty remove it
                if (XMLUtil.isBlank(nodeValue)) {
                    node.removeChild(n);
                    i--;
                }
                // Overwrite the node with the trimmed text
                else {
                    n.setNodeValue(nodeValue);
                }
            } else {
                normalizeDocument(n);
            }
        }
    }

    /**
     * Creates a new root element for the document. <br>
     * Any existing root element will be overwritten, thus descarding any previous data in the document.
     * 
     * @param document
     *            the document to which to append the root element
     * @param elementName
     *            the name of the root element
     * @return the created root element
     */
    public static Element setRootElement(Document doc, String elementName) {
        Element e = doc.createElement(elementName);

        // Overwrite the existing root element
        if (doc.getDocumentElement() != null)
            doc.replaceChild(e, doc.getDocumentElement());
        else
            doc.appendChild(e);

        return e;
    }

    /**
     * Sets a property for the XML transformer.
     * 
     * @param name
     *            Property name
     * @param value
     *            Property value
     * @see javax.xml.transform.OutputKeys
     */
    public static void setTransformerProperty(String name, String value) {
        transformer.setOutputProperty(name, value);
    }

    /**
     * Gets a property for the XML transformer.
     * 
     * @param name
     *            Property name
     * @return The value of the requested property
     * @see javax.xml.transform.OutputKeys
     */
    public static String getTransformerProperty(String name) {
        return transformer.getOutputProperty(name);
    }

    /**
     * Get the first occurence of an element with a specified name, if a element with the specified name can't be found it will be created.
     * 
     * @param el
     *            the parent element
     * @param name
     *            the name of the child element
     * @return a childe element with the name
     */
    public static Element getCreateChildElementByTagName(Element el, String name) {
        Element childEl = getChildElementByTagName(el, name);
        if (childEl == null)
            childEl = XMLUtil.appendChildElement(el, name);

        return childEl;
    }

    /**
     * Returns the first occurence of a child element with a specific name.
     * 
     * @param parent
     *            the parent element
     * @param name
     *            the name of the child element to look for
     * @return the first occurenc of the the name
     */
    public static Element getChildElementByTagName(Element parent, String name) {
        NodeList childList = parent.getChildNodes();
        for (int i = 0; i < childList.getLength(); i++) {
            Node childNode = childList.item(i);
            if (childNode.getNodeType() == Node.ELEMENT_NODE && childNode.getNodeName().equals(name))
                return (Element) childNode;
        }

        return null;
    }

    /**
     * Returns the first element if it exist and <code>null</code> if it does not exist.
     * 
     * @param list
     *            the list
     * @return the first element in the list
     */
    public static Element getElement(NodeList list) {
        if (list.getLength() > 0)
            return (Element) list.item(0);

        return null;
    }

    /**
     * 
     * @param node
     *            -
     * @param path
     *            -
     * @return -
     * @deprecated
     */
    public static Element getElement(Node node, String path) {
        if (path.startsWith("/")) {
            path = path.substring(1);
            Document doc = (Document) XMLUtil.getParent(node);
            String[] pathArr = Pattern.compile("/").split(path);
            return getElement(doc.getDocumentElement(), removeFirstPath(pathArr));
        }

        return null;
    }

    /**
     * Append a child element with a single text node to the supplied element.
     * 
     * @param document
     *            the document
     * @param element
     *            the element to append the child to
     * @param elementName
     *            the name of the element
     * @param elementValue
     *            the value of the element
     * @return the appended child element
     */
    public static Element appendChildElement(Document doc, Element element, String elementName, String elementValue) {
        Element e = doc.createElement(elementName);
        e.appendChild(doc.createTextNode((elementValue == null) ? "" : elementValue));
        element.appendChild(e);
        return e;
    }

    /**
     * Get the value of the element. <br>
     * The method expects the element to have a single <code>TEXT</code> node as child, if so the value of the text node is returned otherwise an empty String
     * is returned.
     * 
     * @param element
     *            The element
     * @param defaultValue
     *            The value to return in case no value was found
     * @return The value
     */
    public static String getElementValue(Element element, String defaultValue) {
        if (element == null || !element.hasChildNodes() || element.getFirstChild().getNodeType() != Node.TEXT_NODE)
            return defaultValue;

        String value = element.getFirstChild().getNodeValue();
        if (value != null)
            value = value.replace('"', ' ').trim();

        return value;
    }

    /**
     * Get the value of the element. <br>
     * The method expects the element to have a single <code>TEXT</code> node as child, if so the value of the text node is returned otherwise an empty String
     * is returned.
     * 
     * @param element
     *            The element
     * @return The value
     */
    public static String getElementValue(Element element) {
        return getElementValue(element, "");
    }

    /**
     * Get the node value from the first element in the node list. <br>
     * The method expects that the nodes in the list are elements and that they have a a child node of the type <code>Text</code> that may be extracted.
     * 
     * @param list
     *            The node list
     * @param defaultValue
     *            The value to return in case no value was found
     * @return The node value of the node, empty String if not found or the method fails
     */
    public static String getElementValue(NodeList list, String defaultValue) {
        if (list.getLength() == 0)
            return defaultValue;

        Element tmpElement = (Element) list.item(0);
        if (!tmpElement.hasChildNodes())
            return defaultValue;

        try {
            return ((Text) tmpElement.getFirstChild()).getNodeValue();
        } catch (Exception ex) {
        }

        return defaultValue;
    }

    /**
     * Get the node value from the first element in the node list. <br>
     * The method expects that the nodes in the list are elements and that they have a a child node of the type Text that may be extracted.
     * 
     * @param list
     *            The node list
     * @return The node value of the node, empty String if not found or the method fails
     */
    public static String getElementValue(NodeList list) {
        return getElementValue(list, "");
    }

    /**
     * Returns the value of the first <code>&lt;Paramter&gt;</code> element that has an <code>name</code> attribute maching the supplied parameter.
     * 
     * @param document
     *            The input Document
     * @param name
     *            Name of the paramter to find
     * @return The value of the parameter, null if not found.
     */
    public static String getFirstParameterValue(Document doc, String name) {
        return getFirstParameterValue(doc.getDocumentElement(), name);
    }

    /**
     * Returns the value of the first <code>&lt;Paramter&gt;</code> element that has an <code>name</code> attribute maching the supplied parameter.
     * 
     * @param parent
     *            The input Element
     * @param name
     *            Name of the paramter to find
     * @return The value of the parameter, null if not found.
     */
    public static String getFirstParameterValue(Element parent, String name) {
        NodeList list = parent.getElementsByTagName("Parameter");

        Element e;
        for (int i = 0; i < list.getLength(); i++) {
            e = (Element) list.item(i);
            if (e.getAttribute("name").equals(name))
                return getElementValue(e);
        }

        return null;
    }

    /**
     * Set the value of an element. <br>
     * Any exiting value on the element is removed.
     * 
     * @param el
     *            the element
     * @param value
     *            the value
     */
    public static void setElementValue(Element el, String value) {
        NodeList children = el.getChildNodes();
        for (int i = 0; i < children.getLength(); i++) {
            if (children.item(i).getNodeType() == Node.TEXT_NODE)
                el.removeChild(children.item(i));
        }
        el.appendChild(((Document) XMLUtil.getParent(el)).createTextNode(value));
    }

    /**
     * Load an XML document from a resource.
     * 
     * @param path
     *            the path to load from
     * @return the document
     * @throws IOException
     * @throws SAXException
     * @throws ParserConfigurationException
     */
    public static Document loadFromResource(String path) throws IOException, SAXException, ParserConfigurationException {
        return docBuilder.parse(XMLUtil.class.getResourceAsStream(path));
    }

    /**
     * Returns an array with all child <code>&lt;Parameter&gt;</code> elements that have a <code>name</code> matching the supplied parameter value.
     * 
     * @param document
     *            Input document
     * @param name
     *            value of the name attribute
     * @return The array
     */
    public static Element[] getParameters(Document doc, String name) {
        return getParameters(doc.getDocumentElement(), name);
    }

    /**
     * Returns an array with all child <code>&lt;Parameter&gt;</code> elements that have a <code>name</code> matching the supplied parameter value.
     * 
     * @param parent
     *            Input element
     * @param name
     *            value of the name attribute
     * @return The array
     */
    public static Element[] getParameters(Element parent, String name) {
        NodeList list = parent.getElementsByTagName("Parameter");

        List<Element> v = new ArrayList<Element>();
        Element e;
        for (int i = 0; i < list.getLength(); i++) {
            e = (Element) list.item(i);
            if (e.getAttribute("name").equals(name))
                v.add(e);
        }

        Element[] returnArray = new Element[v.size()];
        v.toArray(returnArray);
        return returnArray;
    }

    /**
     * Checks if a node value is blank (contains only white spaces).
     * 
     * @param value
     *            The value to check
     * @return false if the value is null or a non white space character is found
     */
    public static boolean isBlank(String value) {
        if (value == null)
            return false;

        for (int i = 0; i < value.length(); i++) {
            char c = value.charAt(i);
            if (!Character.isWhitespace(c))
                return false;
        }

        return true;
    }

    /**
     * Parse an XML document from a file.
     * 
     * @param file
     *            The file
     * @return The document
     * @throws IOException
     * @throws SAXException
     */
    public static Document getDocument(File file) throws IOException, SAXException {
        return docBuilder.parse(file);
    }

    /**
     * Parse an XML document from a file.
     * 
     * @param is
     *            The input source
     * @return The document
     * @throws IOException
     * @throws SAXException
     */
    public static Document getDocument(InputSource is) throws IOException, SAXException {
        return docBuilder.parse(is);
    }

    /**
     * Parse an XML document from a file.
     * 
     * @param path
     *            the file
     * @return the parsed document
     * @throws Exception
     */
    public static Document getDocument(String path) throws Exception {
        return docBuilder.parse(path);
    }

    /**
     * Parse an XML document from a URL.
     * 
     * @param url
     *            The URL from where to parse the document
     * @return The document
     * @throws IOException
     * @throws SAXException
     */
    public static Document getDocument(URL url) throws IOException, SAXException {
        return docBuilder.parse(url.openConnection().getInputStream());
    }

    /**
     * Parse an XML document from an input stream.
     * 
     * @param istream
     *            The stream from where to parse the document
     * @return The document
     * @throws IOException
     * @throws SAXException
     */
    public static Document getDocument(InputStream istream) throws IOException, SAXException {
        return docBuilder.parse(istream);
    }

    /**
     * Removes all child elements to the provided element.
     * 
     * @param element
     *            The element
     */
    public static void removeAllChildElements(Element element) {
        NodeList list = element.getChildNodes();

        /*
         * Copy the elements to a temporary list. This is due to that deleting childs whilst iterating on the node list can result in nodes not beeing deleted.
         */
        List<Element> tmpList = new ArrayList<Element>();
        for (int i = 0; i < list.getLength(); i++) {
            if (list.item(i).getNodeType() != Document.ELEMENT_NODE)
                continue;

            tmpList.add((Element) list.item(i));
        }

        for (Element e : tmpList) {
            element.removeChild(e);
        }
        tmpList.clear();
    }

    /**
     * Remove the element from the document that the element belongs to. <br>
     * If the supplied element is null the method simly returns.
     * 
     * @param e
     *            The element
     * @since 1.1
     */
    public static void removeElement(Element e) {
        if (e == null)
            return;

        Node parent = e.getParentNode();
        parent.removeChild(e);
    }

    /**
     * Remove the element whose ID is provided by elementId from the document. <br>
     * In order for this method to work there has to exists a attribute that is defined as the type <code>ID</code> in the DTD or schema.
     * 
     * @param document
     *            The document from there to remove the element
     * @param elementId
     *            The id
     * @return The removed element, null if not found
     * @since 1.1
     */
    public static Element removeElementById(Document doc, String elementId) {
        Element e = doc.getElementById(elementId);
        removeElement(e);
        return e;
    }

    /**
     * Remove all the elements with the supplied name from the document.
     * 
     * @param document
     *            The document from there to remove the element(s)
     * @param name
     *            The element name
     * @return The number of removed elements
     * @since 1.1
     */
    public static int removeElementByTagName(Document doc, String name) {
        // find out how many elements with the name there are
        int deleted = doc.getElementsByTagName(name).getLength();

        /**
         * delete the elements one by one it's not possible to loop on a node list only every second element would be deleted
         */
        for (int i = 0; i < deleted; i++) {
            removeElement(getElement(doc.getElementsByTagName(name)));
        }

        return deleted;
    }

    /**
     * Save the specified document to file.
     * 
     * @param document
     *            the document to save
     * @param path
     *            the path to the file
     * @see #saveToFile(Document, File)
     */
    public static void saveToFile(Document doc, String path) {
        saveToFile(doc, new File(path));
    }

    /**
     * Save the specified document to file. <br>
     * If the file already exists a backup of the file will be made. <br>
     * Also a comment will be added to the saved document, stating that the file must not be manually edited.
     * 
     * @param document
     *            the document to save
     * @param file
     *            the file to save to
     */
    public static void saveToFile(Document doc, File file) {
        // Don't add the comment if there already is one
        if (doc.getFirstChild().getNodeType() != Document.COMMENT_NODE)
            doc.insertBefore(doc.createComment(COMMENT_DONT_ALTER), doc.getDocumentElement());

        XMLUtil.normalizeDocument(doc);

        if (file.exists()) {
            IOUtil.makeBackup(file);
            file.delete();
        } else {
            file.getParentFile().mkdirs();
        }

        try {
            documentToFile(doc, file);
        } catch (Exception ex) {
            XMLUtil.restoreBackup(file);
            log.log(Level.WARNING, ex.getMessage(), ex);
        }
    }

    private static void restoreBackup(File file) {
        String fileName = file.getName();
        File outputFile = new File(file.getParent(), fileName.substring(0, fileName.indexOf(".bak")));
        IOUtil.copyFileNoException(file, outputFile);
    }

    private static String[] removeFirstPath(String[] path) {
        String[] newPath = new String[path.length - 1];
        for (int i = 0; i < newPath.length; i++) {
            newPath[i] = path[i + 1];
        }
        return newPath;
    }

    private static Element getElement(Element parent, String[] path) {
        Element childEl = null;
        if (parent == null || path.length == 0)
            return null;
        NodeList l = parent.getElementsByTagName(path[0]);
        for (int i = 0; i < l.getLength(); i++) {
            Element tmpEl = (Element) l.item(i);
            if (tmpEl.getParentNode().equals(parent)) {
                childEl = tmpEl;
                break;
            }
        }

        if (childEl == null)
            return null;

        if (path.length > 0) {
            Element tmpEl = getElement(childEl, removeFirstPath(path));
            if (tmpEl != null)
                return tmpEl;
            else if (childEl.getNodeName().equals(path[path.length - 1])) {
                return childEl;
            } else
                return null;
        }

        if (childEl != null)
            return childEl;
        else
            return parent;
    }

    private static Node getParent(Node node) {
        Node parent = node.getParentNode();
        if (parent != null)
            parent = XMLUtil.getParent(parent);

        return (parent != null) ? parent : node;
    }

    /**
     * Iterative method for writing the name/value for each found element into a Map.
     * 
     * @param map
     *            The Map
     * @param e
     *            The element for which to find all child elements
     */
    private static void writeChildElementsToMap(Map<String, String> map, Element e) {
        map.put(e.getNodeName(), getElementValue(e));
        NodeList list = e.getChildNodes();
        for (int i = 0; i < list.getLength(); i++) {
            if (list.item(i).getNodeType() == Node.ELEMENT_NODE)
                writeChildElementsToMap(map, (Element) list.item(i));
        }
    }
}